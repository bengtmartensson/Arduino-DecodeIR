<HTML>
<HEAD>
<TITLE>Interpreting Decoded IR Signals (v2.45)</TITLE>
</HEAD>
<BODY text="#000000" vlink="#666666" alink="#996600" link="#3366cc" bgcolor="#ffffff">
<H2>Version 2.45</H2>
<blockquote>
<A href="#Introduction">Introduction</A><BR><BR>

<table>
<tr><td valign="top" width="140">
<A href="#48-NEC">48-NEC</A><BR>
<A href="#48-NEC1">48-NEC1</A><BR>
<A href="#48-NEC2">48-NEC2</A><BR>
<A href="#AdNotam">AdNotam</A><BR>
<A href="#AirAsync">AirAsync</A><BR>
<A href="#AirB?-????">AirB?-????</A><BR>
<A href="#Aiwa">Aiwa</A><BR>
<A href="#AK">AK</A><BR>
<A href="#Akai">Akai</A><BR>
<A href="#Amino">Amino</A><BR>
<A href="#Anthem">Anthem</A><BR>
<A href="#Apple">Apple</A><BR>
<A href="#Archer">Archer</A><BR>
<A href="#Async">Async</A><BR>
<A href="#Barco">Barco</A><BR>
<A href="#Blaupunkt">Blaupunkt</A><BR>
<A href="#Bryston">Bryston</A><BR>
<A href="#Bose">Bose</A><BR>
<A href="#CanalSat">CanalSat</A><BR>
<A href="#CanalSatLD">CanalSatLD</A><BR>
<A href="#Denon">Denon</A><BR>
<A href="#Denon">Denon{1}</A><BR>
<A href="#Denon">Denon{2}</A><BR>
<A href="#Denon-K">Denon-K</A><BR>
<A href="#Dgtec">Dgtec</A><BR>
<A href="#DirecTV">DirecTV</A><BR>
<A href="#Dishplayer">Dishplayer</A><BR>
<A href="#Dish_Network">Dish_Network</A><BR>
</td>
<td valign="top" width="144">
<A href="#Elan">Elan</A><BR>
<A href="#Emerson">Emerson</A><BR>
<A href="#F12">F12</A><BR>
<A href="#F32">F32</A><BR>
<A href="#Fujitsu">Fujitsu</A><BR>
<A href="#Fujitsu-56">Fujitsu-56</A><BR>
<A href="#G.I. Cable">G.I. Cable</A><BR>
<A href="#G.I. Cable">G.I. Cable{1}</A><BR>
<A href="#G.I. 4DTV">G.I. 4DTV</A><BR>
<A href="#G.I. RG">G.I. RG</A><BR>
<A href="#Grundig16">Grundig16</A><BR>
<A href="#Grundig16">Grundig16-30</A><BR>
<A href="#GXB">GXB</A><BR>
<A href="#GXB">Humax 4Phase</A><BR>
<A href="#IODATAn">IODATA<i>n</i></A><BR>
<A href="#IODATAn">IODATA<i>n</i>-<i>x</i>-<i>y</i></A><BR>
<A href="#Jerrold">Jerrold</A><BR>
<A href="#JVC">JVC</A><BR>
<A href="#JVC">JVC{2}</A><BR>
<A href="#JVC-48">JVC-48</A><BR>
<A href="#JVC-56">JVC-56</A><BR>
<A href="#Kaseikyo">Kaseikyo</A><BR>
<A href="#Kaseikyo56">Kaseikyo56</A><BR>
<A href="#Kathrein">Kathrein</A><BR>
<A href="#Konka">Konka</A><BR>
<A href="#Logitech">Logitech</A><BR>
</td>
<td valign="top" width="142">
<A href="#Lumagen">Lumagen</A><BR>
<A href="#Lutron">Lutron</A><BR>
<A href="#Matsui">Matsui</A><BR>
<A href="#MCE">MCE</A><BR>
<A href="#Metz19">Metz19</A><BR>
<A href="#Mitsubishi">Mitsubishi</A><BR>
<A href="#Mitsubishi-K">Mitsubishi-K</A><BR>
<A href="#NEC">NEC</A><BR>
<A href="#NEC1">NEC1</A><BR>
<A href="#NEC2">NEC2</A><BR>
<A href="#NECx">NECx</A><BR>
<A href="#NECx1">NECx1</A><BR>
<A href="#NECx2">NECx2</A><BR>
<A href="#Nokia">Nokia</A><BR>
<A href="#Nokia12">Nokia12</A><BR>
<A href="#Nokia32">Nokia32</A><BR>
<A href="#NRC16">NRC16</A><BR>
<A href="#NRC17">NRC17</A><BR>
<A href="#OrtekMCE">OrtekMCE</A><BR>
<A href="#Pace MSS">Pace MSS</A><BR>
<A href="#Panasonic">Panasonic</A><BR>
<A href="#Panasonic2">Panasonic2</A><BR>
<A href="#Panasonic_Old">Panasonic_Old</A><BR>
<A href="#PCTV">PCTV</A><BR>
<A href="#pid-0001">pid-0001</A><BR>
<A href="#pid-0003">pid-0003</A><BR>
<A href="#pid-0004">pid-0004</A><BR>
<A href="#pid-0083">pid-0083</A><BR>
</td>
<td valign="top" width="131">
<A href="#Pioneer">Pioneer</A><BR>
<A href="#Proton">Proton</A><BR>
<A href="#RC5">RC5</A><BR>
<A href="#RC5-7F">RC5-7F</A><BR>
<A href="#RC5-7F-57">RC5-7F-57</A><BR>
<A href="#RC5x">RC5x</A><BR>
<A href="#RC5-?-??">RC5-?-??</A><BR>
<A href="#RC6">RC6</A><BR>
<A href="#RC6-6-20">RC6-6-20</A><BR>
<A href="#RC6-?-??">RC6-?-??</A><BR>
<A href="#RCA">RCA</A><BR>
<A href="#RCA">RCA(Old)</A><BR>
<A href="#RCA-38">RCA-38</A><BR>
<A href="#RCA-38">RCA-38(Old)</A><BR>
<A href="#RECS80">RECS80</A><BR>
<A href="#Replay">Replay</A><BR>
<A href="#Revox">Revox</A><BR>
<A href="#Samsung20">Samsung20</A><BR>
<A href="#Samsung36">Samsung36</A><BR>
<A href="#Sampo">Sampo</A><BR>
<A href="#ScAtl-6">ScAtl-6</A><BR>
<A href="#Sejin-M-38">Sejin-<i>M</i>-38</A><BR>
<A href="#Sejin-M-38">Sejin-<i>M</i>-56</A><BR>
<A href="#Sharp">Sharp</A><BR>
<A href="#Sharp">Sharp{1}</A><BR>
<A href="#Sharp">Sharp{2}</A><BR>
<A href="#SharpDVD">SharpDVD</A><BR>
<A href="#SIM2">SIM2</A><BR>
</td>
<td valign="top" width="130">
<A href="#Solidtek16">Solidtek16</A><BR>
<A href="#Solidtek20">Solidtek20</A><BR>
<A href="#Somfy">Somfy</A><BR>
<A href="#Sony8">Sony8</A><BR>
<A href="#Sony12">Sony12</A><BR>
<A href="#Sony15">Sony15</A><BR>
<A href="#Sony20">Sony20</A><BR>
<A href="#StreamZap">StreamZap</A><BR>
<A href="#Sunfire">Sunfire</A><BR>
<A href="#TDC-38">TDC-38</A><BR>
<A href="#TDC-38">TDC-56</A><BR>
<A href="#Teac-K">Teac-K</A><BR>
<A href="#Thomson">Thomson</A><BR>
<A href="#Thomson7">Thomson7</A><BR>
<A href="#Tivo">Tivo</A><BR>
<A href="#Velleman">Velleman</A><BR>
<A href="#Velodyne">Velodyne</A><BR>
<A href="#Viewstar">Viewstar</A><BR>
<A href="#X10">X10</A><BR>
<A href="#X10">X10.<i>n</i></A><BR>
<A href="#XMP">XMP</A><BR>
<A href="#XMP">XMP-1</A><BR>
<A href="#XMP">XMP-2</A><BR>
<A href="#XX">XX</A><BR>
<A href="#Zaptor">Zaptor</A><BR>
<A href="#Zenith">Zenith</A><BR>
<A href="#?1-??-??-??">?1-??-??-??</A><BR>
</td></tr></table>


<H2><A name="Introduction">Introduction</A></H2>
The primary purpose of this document is to explain any peculiarities of the decoding of each protocol.
Click in the list above on each protocol name to get any information specific to decodes with that name.
<p>If you don't understand the advanced information (IRP notation, etc.) at the start of each of those
entries, don't worry about that and please don't let it stop you from reading the text below that.  In many
cases there is important protocol-specific information you will need in order to use the data from
the decode.</p>
<H3>Decode problems</H3>
The decoder only looks at one IR signal at a time.  Sometimes it gives contradictory
results for a signal.  The best way to determine which result is correct is to
compare with the decodes of other signals for the same device.
<H3><A name="spurious">Spurious decodes and non-robust protocols</A></H3>
Most IR protocols have enough internal consistency checks that the decoder can reliably
tell whether that protocol is present in a learned signal and can reliably decode the
device, subdevice and OBC numbers.  If the signal is learned badly enough, the decoder
may fail to find that protocol in the signal.  But it is very unlikely to decode it
with the wrong numbers or to imagine that protocol is a bad learn of something else.
  <p>Some protocols are not robust. A totally unrelated IR signal can accidentally 
    fit the pattern of such a protocol resulting in a spurious decode. When you 
    get a decode for a non-robust protocol you need to exercise some judgment 
    about whether to believe or ignore that decode. Usually you can decide based 
    on decodes of other signals of the same device.</p>
<H3><A name="jp1">EFC, JP1, KeyMoves, Upgrades, etc.</A></H3>
Much of this document assumes DecodeIr is being used with JP1 or at least with a JP1
capable remote.  But some people will be using DecodeIr with other types of remote.
<p>If your remote is not OneForAll brand and is not one of the models of Radio Shack (or a few
other brands) that uses the same design as OneForAll, then everything this document says
about JP1, KeyMoves, Upgrades, KM, RM (RemoteMaster), and EFC numbers has no meaning for
your use.  Just ignore those references and the rest of this doc should apply to your use.
Also ignore the EFC numbers in the actual output from DecodeIr.</p>
<p>If you are using a OneForAll type remote but have neither a JP1 cable nor a remote model
that can be upgraded by .wav file, then nothing about Upgrades, KM, RM, and OBC numbers
applies to your use.  If the decodes you get include EFC numbers and you know (or can
ask in a forum) which setup code is right (corresponds to the protocol, device and
subdevice of the decode) then you can use those EFC numbers in KeyMoves.  Note that
the decoding process cannot directly tell you which setup code is needed to
generate the signal.  If you post a question in an appropriate forum with the protocol name,
device number, subdevice number, and which model OneForAll type remote you have, someone
will probably identify the setup code for you.</p>
<H3><A name="toggle">Toggle bits</A></H3>
Several different protocols include something called a toggle bit.  This means that each command
has two or more different forms.  Some protocols (e.g. RC5) alternate the toggle on each key press, while
others change the toggle to indicate a start or end frame.
<p>An alternating toggle lets the device receiving the commands distinguish between a long press
of a button and two short presses.  For example, if you press and hold the '1' button
the remote continuously sends repeats of a single form of the '1' command.  But if you
press '1', release it and press it again the remote will switch to the other form of the
command for the second press.</p>
<p>When you learn such a command you are capturing just one form of the command and
every use will send that same form.  If you use that learned signal and press the same button twice
in a row, the device receiving the signal will see that as one long press rather than two
short ones.  For keys, such as digits, where one long press has a different meaning than
two short presses, that gets quite inconvenient.</p>
<p>With OneForAll type remotes, using an upgrade or KeyMove will solve that problem.</p>
<p>For some of these protocols, for some models of Pronto remote, there is a condensed
encoding of the Pronto Hex that will solve the problem.</p>

<H3><A name="repeat">Repeat frames and dittos</A></H3>
<p>DecodeIR v2.37 and later versions have a look-ahead facility that is not present in earlier ones.  
    This distinguishes between two styles of data passed to them by the calling application.  The 
    remote control programming applications IR.exe and RMIR pass signals learned by a UEI remote 
    that has itself performed a partial analysis of the signal.  The data is passed in a structured 
    form, divided into Once, Repeat and Extra sections.  The data in each of these sections can be 
    viewed in IR.exe if the "Force Learned Timings" option on the Advanced menu is selected.  Because 
    of this analysis, DecodeIR does not see the original signal in full and cannot determine such 
    things as the number of repeats of the signal that were sent.  Other applications such as the 
    IRScope software for the IR Widget send the entire signal as unstructured data, which enables 
    IR.exe to identify the number of repeats.</p>
<p>The look-ahead facility checks successive frames within a single signal to see if they are 
    repeats &#8211; either identical repeats or, in certain protocols, frames of a repeat sequence 
    that have a distinctive marker in either the start or end frame, or both, of the sequence.  If a 
    protocol has distinctive start or end frame markers and either or both of the start and end frames 
    are missing, this is reported in the Misc field of the decode (but at present this may not be 
    implemented for all protocols with such markers).  If the data has been passed in an unstructured 
    form then the number of repeats in the signal will also be reported in the Misc field in a form 
    like &quot;4 frames&quot;, or in version 2.39 and later, &quot;+ 3 copies&quot;.</p>
<p>In the case of unstructured data, DecodeIR v2.38 extends the look-ahead to protocols in which repeat 
    action is signalled not by a full repeat of the frame but by a much shorter frame that does not carry 
    the signal data (or occasionally carries just part of this data).  These frames serve 
    as &quot;ditto marks&quot;.  If present then the number of such frames is reported in the Misc field 
    in a form like &quot;3 dittos&quot;, or in version 2.39 and later, &quot;+ 3 dittos&quot;.  If there 
    are no repeat frames or ditto marks, then to avoid ambiguity this is reported as &quot;no repeat&quot;.</p>

<H3><A name="MiniComboExecutors">Mini Combos</A></H3>
Some UEI protocol executors are &quot;mini-combos&quot;.  This means they support more than one
device number within one setup code using single-byte hex commands.  There will be more
than one possible EFC number for each OBC number.  DecodeIr can't determine the correct
EFC number by looking at the IR signal, because it isn't a characteristic of the signal.
It is a characteristic of the fixed data used in creation of the setup code.
<p>DecodeIr will list two or three different EFC numbers for each OBC number.
The sequence of those two or three EFC numbers is consistent across all the decodes.
So once you find out which position in that list is correct for one OBC of a given device
number and setup code, that position will be correct for the EFC list of any other OBC of
the same device and setup code (except that for RC-5 the decision of whether or not the OBC
number is above 63 is treated as being part of the device number).</p>

<H3><A name="ReadingIRP">Brief and incomplete guide to reading IRP</A></H3>

<b>General</b>: {carrier frequency, time unit, sequencing rule} 
Mitsubishi:<b>{32.6k,300}</b>&lt;1,-3|1,-7&gt;(D:8,F:8,1,-80)+ <br>
<i>Carrier Frequency</i>: Hz; e.g. 38.3k; default is 0k--no  modulation<br>
<i>Time Unit</i>: Integer that can represent durations.  Suffix u (default) is microseconds, p denotes number of pulses of the carrier.<br>
<i>Sequencing Rule</i>:  lsb|msb; lsb (default) means the least significant bit of a binary form is sent first. <br>
<b>BitSpec</b>: Rule for the translating bit sequences to duration sequences.  &lt;ZeroPulseSeq|OnePulseSeq|TwoPulseSeq....&gt;.  Most IR protocols use only &lt;ZeroPulseSeq|OnePulseSeq&GT;, and the sequence is simply OnDuration,OffDuration.    Example: NEC uses  &lt;1,-1|1,-3&GT;<br>

<b>Bitfield</b>:  D:NumberOfBits:StartingBit.  E.g. if D=47= 01000111, D:2:5 means x<b>10</b>xxxxx.  D:2:5 = 10b = 2.   ~ is the bitwise complement operator.  ~D =10111000. Specifying the StartingBit is optional. D:6 is equivalent to D:6:0.<br>

<b>IRStream</b>: The sequence of data. Enclosed in parentheses, items separated by commas. 
A trailing + means send one or more times.  A trailing 3 means send 3 times; 3+ means at least 3 times.   
A trailing * means send zero or more times. NEC2: {38.4k,564}&lt;1,-1|1,-3&gt;<b>(16,-8,D:8,S:8,F:8,~F:8,1,-78)+</b> <br>

<b>Durations</b>: no suffix means duration is expressed in Time Units, as defined above.  
m is milliseconds, u microsec, p pulses.  No prefix means a flash, a preceeding - (minus) means a gap.<br>

<b>Extent</b>: A gap which trails a signal.   The trailing gap is adjusted to make the total length of signal 
plus trailing gap equal to the extent. Notation is like a gap duration, except ^ replaces the minus sign. 
RC-5:(1:1,~F:1:6,T:1,D:5,F:6,<b>^114m</b>)+ <br>

<b>Expressions</b>:   names, numbers and bitfields connected by standard symbols for arithmetic and logical 
operations.  Enclosed in parentheses. Panasonic: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,2:8,32:8,D:8,S:8,F:8,<b>(D^S^F)</b>:8,1,-173)+ 
 <br>  

<b>Permitted operators in decreasing order of precedence:</b><br>
<code>
      unary –   (negation)<br>
      **  (exponentiation)<br>
      * /, %  (multiplication, integer division, modulo) (* is also used in IRStreams)<br>
      +, –   (addition, subtraction  (+ is also used in IRStreams)<br>
	  #		number of 1 bits in argument<br>
      &       (bitwise AND)<br>
      ^        (exclusive OR)  (also used in extents)<br>
      |        (OR)<br>
      ~     (complement) is permitted in Bitfields</code><br>

<b>Definitions</b>:  expressions separated by commas, enclosed in curly brackets. 
GI Cable: {38.7k,490}&lt;1,-4.5|1,-9&gt;(18,-9,F:8,D:4,C:4,1,-84,(18,-4.5,1,-178)*) 
<b>{C = -(D + F:4 + F:4:4)}</b> <br>
<b>Assignments</b>:  For example T=T+1, which can be used to describe the RC-5 toggle bit.<br>
<b>Variations</b>:  Up to 3 expressions enclosed in square brackets.  The first variation is 
sent on the first transmission, second for middle transmissons, and the third for the final transmission. 
E.g. the Zaptor toggle bit is zero until the last frame: [T=0] [T=0] [T=1]<br>
<a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation"> The IRP specification by Graham Dixon</a><br>
<a href="http://www.hifi-remote.com/forums/dload.php?action=file&file_id=6996"> Practical explanation of IR signals and IRP by Vicky Getz</a>

    
<H2><A name="48-NEC">48-NEC</A></H2>
If you get a decode whose protocol name is
simply &quot;48-NEC&quot; that indicates the learned signal is not complete (usually caused by
not holding the original remote's button long enough during learning).  Enough of
the signal is present to accurately determining the device, subdevice and OBC numbers.
But not enough is present to determine whether the protocol is 48-NEC1 or 48-NEC2.

<H2><A name="48-NEC1">48-NEC1</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m,(16,-4,1,^108m)*) 
<br>
EFC translation: LSB comp
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</p> 

<H2><A name="48-NEC2">48-NEC2</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m)+ 
<br>
EFC translation: LSB comp

<H2><A name="AdNotam">AdNotam</A></H2>
IRP notation: {35.7Khz,895,msb}&lt;1,-1|-1,1&gt;(1,-2,1,D:6,F:6,^114m)+ 
<br>
<p>Very similar to RC5, except AdNotam uses two start bits, and no toggle bit.    


<H2><A name="AirAsync">AirAsync</A></H2>
IRP notation: {37.7Khz,840}&lt;1|-1&gt;(N=0,(1,B:8:N,-2,N=N+8)+)
<p>This protocol uses asynchronous data transmission that sends an 8-bit byte with 1 start bit, 
8 data bits and 2 stop bits.  The minimum signal is one byte.  The protocol is reported as
AirAsync<i>n</i>-xx.yy. ...
where <i>n</i> is the number of bytes and xx, yy, ... are the byte values in hexadecimal notation.  
</p>

<H2><A name="AirB?-????">AirB?-????</A></H2>
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.
If you see this decode from something other than an IR keyboard, you should probably ignore it.</p>

<H2><A name="Aiwa">Aiwa</A></H2>
UEI protocol: 005E or 009E
<br>
IRP notation: {38k,550}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:5,~D:8,~S:5,F:8,~F:8,1,-42,(16,-8,1,-165)*) 
<br>
EFC translation: LSB
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</p>
<p>The EFC numbering varies among the KM and RM versions of Aiwa.  Using OBC numbers is less confusing.</p>
<p>When using a non-combo version of Aiwa in KM, you must combine the device and subdevice numbers as
device+256*subdevice to get the number KM calls &quot;Device Code&quot;.  (Since subdevice is usually zero, that
combination is trivial).  In Aiwa combo in KM you use the subdevice as &quot;parameter&quot; (on the setup sheet)
and put the device in the byte2 column on the functions sheet.  RM follows DecodeIr's naming of Device
and Subdevice.</p>

<H2><A name="AK">AK</A></H2>
Documentation not written yet.

<H2><A name="Akai">Akai</A></H2>
UEI protocol: 000D
<br>
IRP notation: {38k,289}&lt;1,-2.6|1,-6.3&gt;(D:3,F:7,1,^25.3m)+ <br>
EFC translation: LSB comp prefixed with last device bit
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>
<p>As of version 8.31, KM does not translate device to fixed data, nor OBC to EFC according to
the same rules used by DecodeIr.  RM does translate consistently with DecodeIr, so you may find
it easier to use RM.  If you use KM, you must change the device number as follows:</p>
<ul>
<li>Decoded device 0 or 4 --&gt; KM device 3</li>
<li>Decoded device 1 or 5 --&gt; KM device 2</li>
<li>Decoded device 2 or 6 --&gt; KM device 1</li>
<li>Decoded device 3 or 7 --&gt; KM device 0</li>
</ul>
<p>Also (in KM) you should use the EFC number from the decode not the OBC number.  Akai protocol
uses the same EFC numbering across all JP1 remotes, so use of EFC is safe.  KM uses different
OBC numbering than RM and DecodeIr, so use of OBCs isn't safe.</p>

<H2><A name="Amino">Amino</A></H2>
UEI protocol: 019C
<br>
IRP notation: {56.0k,268,msb}&lt;-1,1|1,-1&gt;[T=1] [T=0] (7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m)+<br>
-----Variant: {36.0k,268,msb}&lt;-1,1|1,-1&gt;[T=1] [T=0] (7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m)+
<br>{C =(D:4+4*T+9+F:4+F:4:4+15)&15}  [the arithmetic sum of the first 7 nibbles mod 15]
<br>T=1 for the first frame and T=0 for all repeat frames.  
<br>DecodeIR v2.43 checks T and will report in the Misc field if the start or end frame is missing.
Amino equipment use both 36 and 56KHz, but the duration of the half-bit is
always 268.  Zaptor is a closely related protocol which for which the half-bit duration is 330.
IRDecode v2.43 distinguishes between Amino and Zaptor in order of priority by 1)the position of the toggle bit,
2)the value of the next to last nibble, and 3)the measured duration of a half-bit.
<br>
EFC translation: MSB

<H2><A name="Anthem">Anthem</A></H2>
UEI protocol: 0123 <br>
IRP notation: {38.0k,605}<1,-1|1,-3>((8000u,-4000u,D:8,S:8,F:8,C:8,1,-25m)3, -75m)+ {C=~(D+S+F+255):8}
<br>Anthem framing is very similar to NEC, and also uses 32 bits of data.  However, the leadout is much shorter.
The signal is sent at least 3 times. Anthem usually splits F into a 2 bit unit number, and a 6 bit function number. 

<H2><A name="Apple">Apple</A></H2>
UEI protocol: 01E0
<br>

IRP notation: {38.0k,564}<1,-1|1,-3>(16,-8,D:8,S:8,C:1,F:7,I:8,1,^108m,(16,-4,1,^108m)*) {C=~(#F+#PairID)&1)}<br>
C=1 if the number of 1 bits in the fields F and I is even.  I is the remote ID.
<p> Apple uses the same framing as NEC1, with D=238 in normal use, 224 while pairing.  S=135 </p>

<H2><A name="Archer">Archer</A></H2>
IRP notation: {0k,12}&lt;1,-3.3m|1,-4.7m&gt;(F:5,1,-9.7m)+ <br>
EFC translation: 5-bit LSB
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="Async">Async</A></H2>
<p>This protocol uses asynchronous data transmission that sends an 8-bit byte with 1 start bit, 
8 data bits and 1 stop bit.  The minimum signal is four bytes.  The protocol is reported as
Async<i>n</i>:min-max:aa.bb...yy.zz
where <i>n</i> is the number of bytes, min-max is the range of durations in microseconds that was taken as a single bit and aa.bb...yy.zz are the first two and last two byte values in hexadecimal notation.  DecodeIR v 2.44 does not report Async decodes.
</p>

<H2><A name="Barco">Barco</A></H2>
UEI protocol: 002A
<br>IRP notation: {0k,10}&lt;1,-5|1,-15&gt;(1,-25, D:5,F:6, 1,-25,1,120m)+
<br>EFC translation: 6-bit LSB comp
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</p>

<H2><A name="Blaupunkt">Blaupunkt</A></H2>
IRP notation: {30.3k,528}&lt;-1,1|1,-1&gt;(1,-5,1023:10,-39,1,-5,1:1,F:6,D:3,-230) 

<H2><A name="Bose">Bose</A></H2>
UEI protocol: 010C<br>
IRP notation: {38.0k,500,msb}&lt;1,-1|1,-3&gt;(2,-3,F:8,~F:8,1,-50m)+ <br>
EFC translation: MSB

<H2><A name="Bryston">Bryston</A></H2>
IRP notation: {38.0k,315} &lt;1,-6|6,-1&gt;(D:10,F:8, -18m)+ <br>

<H2><A name="CanalSat">CanalSat</A></H2>
UEI protocol: 018C

IRP notation: {55.5k,250,msb}&lt;-1,1|1,-1&gt;(T=0,(1,-1,D:7,S:6,T:1,0:1,F:7,-89m,T=1)+) 
<br>
EFC translation: 7-bit MSB.
<p>The <A href="#repeat">repeat frames</A> are not all identical.  T toggles within a single signal, with T=0
for the start frame and T=1 for all repeats.  DecodeIR v2.37 and later check T and will report in the Misc
field if the start frame is missing.  The official name for CanalSat is "ruwido r-step".</p>

<H2><A name="CanalSatLD">CanalSatLD</A></H2>
UEI protocol: unknown <br>
IRP notation: {56k,320,msb}&lt;-1,1|1,-1&gt;(T=0,(1,-1,D:7,S:6,T:1,0:1,F:6,~F:1,-85m,T=1)+)
<p>The official name for CanalSatLD is "ruwido r-step"</p>

<H2><A name="Denon">Denon, Denon{1} and Denon{2}</A></H2>
IRP notation: {38k,264}&lt;1,-3|1,-7&gt;(D:5,F:8,0:2,1,-165,D:5,~F:8,3:2,1,-165)+ 
<br>
EFC translation: LSB
<p>A Denon signal is identical to Sharp, and has two halves, either one of which is enough 
to fully decode 
the information. A significant fraction of Denon learned signals contain just 
one half or have the halves separated so that DecodeIr can't process them 
together. When one half is seen separate from the other, DecodeIr will name 
the protocol Denon{1} or Denon{2} depending on which half is decoded. Denon, 
Denon{1} and Denon{2} all represent the same protocol when they are correct. 
But only Denon is robust. A Denon{1} or Denon{2} decode might be <A href="#spurious">spurious</A>.</p>

<H2><A name="Denon-K">Denon-K</A></H2>
UEI protocol: 00CD, 01C8
<br>
IRP notation: {37k,432}&lt;1,-1,1,-3&gt;(8,-4,84:8,50:8,0:4,D:4,S:4,F:12,((D*16)^S^(F*16)^(F:8:4)):8,1,-173)+ 
<br>
EFC translation: LSB comp
<p>Denon-K is the member of the Kaseikyo family with OEM_code1=84 and OEM_code2=50.</p>
<p>Denon-K uses the same check byte rules as Panasonic protocol, but uses the data bits differently.
The Panasonic Combo protocol in KM can be used with some difficulty to produce Denon-K signals.
The Denon-K choice in RM uses the same protocol executor as Panasonic combo, but computes the hex commands
based on Denon's use of the Kaseikyo data bits.</p>

<H2><A name="Dgtec">Dgtec</A></H2>
UEI protocol: 016A
<br>
IRP notation: {38k,560}&lt;1,-1|1,-3&gt;(16,-8,D:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)+) 
<br>
EFC translation: LSB comp
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</p>

<H2><A name="DirecTV">DirecTV</A></H2>
IRP notation: {38k,600,msb}&lt;1,-1|1,-2|2,-1|2,-2&gt;(5,(5,-2,D:4,F:8,C:4,1,-50)+) 
{C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)} <br>
EFC translation: MSB
<p>There are six variants of the DirecTV protocol, distinguished in RemoteMaster by the parameter "Parm" on
the Setup page.  The Parm value is shown in the Misc field of DecodeIR.  The IRP notation above corresponds
to the default Parm=3.  The various Parm values correspond to three different frequencies (the 38k in the above) 
and two different lead-out times (the -50 in the above).  The corresponding values are:</p>
<ul>
<li>Parm=0 : 40k, -15
<li>Parm=1 : 40k, -50
<li>Parm=2 : 38k, -15
<li>Parm=3 : 38k, -50
<li>Parm=4 : 57k, -15
<li>Parm=5 : 57k, -50
</ul> 
<p>Portions of a dirty learn of a Sony signal may look like a DirecTV signal.  So, if you get a DirecTV
decode together with a plausible Sony decode, believe the Sony decode and ignore the DirecTV.  If you get
a DirecTV decode without a Sony decode for some functions of a Sony device, try relearning them;  a DirecTV
decode for a signal meant for a Sony device is not likely to be correct.</p>
<p>This protocol was called Russound in versions of DecodeIR earlier than 2.40.</p>

<H2><A name="Dishplayer">Dishplayer</A></H2>
UEI protocol: 010F
<br>
IRP notation: {38.4k,535,msb}&lt;1,-5|1,-3&gt;(1,-11,(F:6,S:5,D:2,1,-11)+) <br>
EFC translation: Not available in this version of DecodeIr
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="Dish_Network">Dish_Network</A></H2>
UEI protocol: 0002 <br>IRP notation: {57.6k,400}&lt;1,-7|1,-4&gt;(1,-15,(F:-6,S:5,D:5,1,-15)+)
<br>
EFC translation: MSB comp 6 function bits followed by LSB comp low 2 unit bits.
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>
<p>The unit number shows up in the Subdevice field of DecodeIr's output.  In KM, the &quot;unit code&quot; is
one greater than the unit number.  So you must take the Subdevice from the decode and add one to
it and use that as the &quot;unit code&quot; in KM.</p>
<p>There are two variants of the protocol executor for DishNetwork with different 
but compatible EFC numbering. The decoded EFC should work for both. But the 
results may be less confusing if you use OBC numbers in KM or RM.</p>

<H2><A name="EchoStar">EchoStar</A></H2>
UEI protocol: 0182
<br> As of 2.42 DecodeIR shows this as RC5-7F

<H2><A name="Elan">Elan</A></H2>
UEI protocol: Unknown<br>
IRP notation: {40.2k,398,msb}&lt;1,-1|1,-2&gt;(3,-2,D:8,~D:8,2,-2,F:8,~F:8,1,^50m)+ <br>
<p>See the <A href="http://www.hifi-remote.com/forums/viewtopic.php?p=87473">JP1-forum</A> for the executor.</p>

<H2><A name="Emerson">Emerson</A></H2>
UEI protocol: 0065
<br>
IRP notation: {36.7k,872}&lt;1,-1|1,-3&gt;(4,-4,D:6,F:6,~D:6,~F:6,1,-39)+ <br>
EFC translation: 6-bit LSB comp with 2-bit mini-combo
<p>Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.</p>

<H2><A name="F12">F12</A></H2>
UEI protocol: 001A
<br>
IRP notation: (Toshiba specification)
{37.9k,422}&lt;1,-3|3,-1&gt;(D:3,H:1,A:1,B:1,F:6),-80)2 for A=1 or B=1 <br>
{37.9k,422}&lt;1,-3|3,-1&gt;((D:3,H:1,A:1,B:1,F:6),-80)2,-128)+ for H=1.<br>
Exactly one of H, A, or B can have a value of 1.  If H=1 the signal can be sent repeatedly, and F can take any 6 bit value.
If A or B=1, the signal is sent once only per button press, and only a single bit of F can be non-zero.  <A href="http://www.hifi-remote.com/forums/dload.php?action=file&file_id=9832">Toshiba spec sheet</A> <p>
IRP notation: (JP1)
{37.9k,422}&lt;1,-3|3,-1&gt;((D:3,S:1,F:8,-80)2,-128)+  <br>
A and B are subsumed into F, and the value of H is computed by the executor. H=A^B.
<br>EFC translation: lsb, but not computed in DecodeIR.
<br> DecodeIR reports H as the subdevice.  This is useful when making a Pronto Hex file,
or other description based on durations.  Remotes with executors (e.g. UEI remotes) normally compute the value of
H in the executor, and the "subdevice" is not needed as a parameter.

<H2><A name="F32">F32</A></H2>
UEI protocol: Unknown
<br>
IRP notation: {37.9k,422,msb}&lt;1,-3|3,-1&gt;(D:8,S:8,F:8,E:8,-100m)+ <br>
<p>The meaning of the 32 bits of data is unknown, and the assignment to D, S, F, and E is arbitrary </p>

<H2><A name="Fujitsu">Fujitsu</A></H2>
UEI protocol: 00F8
<br>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,F:8,1,-110)+ 
<br>
EFC translation: LSB comp
<p>Fujitsu is the member of the Kaseikyo family with OEM_code1=20 and OEM_code2=99.
There is no check byte, so the risk of an incorrectly decoded OBC is much higher than in
other Kaseikyo protocols.</p>
  <p>00F8 requires 2-byte hex commands, so the decoded EFC number is generally not 
    useful. Use OBC number in upgrades or to compute Hex commands.</p>

<H2><A name="Fujitsu-56">Fujitsu-56</A></H2>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,X:8,F:8,1,-110)+ 

<H2><A name="G.I. Cable">G.I. Cable and G.I. Cable{1}</A></H2>
UEI protocol: 00C4
<br>
IRP notation: {38.7k,490}&lt;1,-4.5|1,-9&gt;(18,-9,F:8,D:4,C:4,1,-84,(18,-4.5,1,-178)*) 
{C = -(D + F:4 + F:4:4)} <br>
EFC translation: LSB
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.
When the {1} is shown as part of the protocol name for G.I. Cable, it just means that the repeat
part of the signal is not present.  That doesn't indicate any difference in the actual protocol nor
even any unreliability in the decode.  It may indicate that use of the learned signal will be less
reliable, so you have more than usual reason to replace it with a <A HREF="#jp1">KeyMove, Upgrade</A> or cleaned
up version.</p>

<H2><A name="G.I.4DTV">G.I.4DTV</A></H2>
UEI protocol: 00A4
<br>
IRP notation: {37.3k,992}&lt;1,-1|1,-3&gt;(5,-2,F:6,D:2,C:4,1,-60)+ 
{C= ((#(F&25) + #(D&5))&1) + 2*((#(F&43) + #(D&7))&1) + 4*((#(F&22) + #(D&7))&1) + 8*((#(F&44) + #(D&6))&1)} <br>
EFC translation: NONE
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible</p>
<p>Unit (device) numbers from 0 to 7 are supported.  The check sum C is a Hamming Code, which can correct single bit errors. 
D:1:2 is encoded in the check sum. <A href="http://www.hifi-remote.com/forums/viewtopic.php?p=103934#103934">D encoding scheme</A> 
The official (UEI) protocol executor for G.I.4DTV does not support EFC numbers.  If you are creating an
upgrade in KM or RM you should use OBC numbers, not EFC numbers.  If you need the Hex Cmd for a KeyMove,
you should use the functions sheet of KM or RM to compute it for you from the OBC and device number.</p>

<H2><A name="G.I.RG">G.I.RG</A></H2>
UEI protocol: unknown
<br>
IRP notation: {37.3k,1000, msb}&lt;1,-1|1,-3&gt;(5,-3,F:6,S:2,D:8,1,-60)+  <br>
EFC translation:  
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible, 
especially SIM2 which has nearly identical timing.</p>
<p>Typical usage is the GI/Next Level/Motorola RG2x00 series</p>

<H2><A name="Grundig16">Grundig16 and Grundig16-30</A></H2>
UEI protocol:  Grundig16 0112, Grundig16-30 00AB
<br>IRP notation for Grundig16: {35.7k,578,msb}&lt;-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1&gt;
(806u,-2960u,1346u,T:1,F:8,D:7,-100)+
<br>IRP notation for Grundig16-30: {30.3k,578,msb}&lt;-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1&gt;
(806u,-2960u,1346u,T:1,F:8,D:7,-100)+ 
 <br>
EFC translation:  MSB but with bit pairs translated data-&gt;hex by 00-&gt;00, 01-&gt;11, 10-&gt;01, 11-&gt;
10 and off by one position.
<p>These are two variants of the same protocol, differing only in frequency.  The IRP notation is corrected 
    from previous versions of this document, to bring it into line with what DecodeIR actually does.</p>

<H2><A name="GXB">GXB</A></H2>
IRP notation: {38.3k,520,msb}&lt;1,-3|3,-1&gt;(1,-1,D:4,F:8,P:1,1,^???)+ 
<p>Decoder for a nonstandard Xbox remote.</p>

<H2><A name="Humax 4Phase">Humax 4Phase</A></H2>
IRP notation: {56k,105, msb}&lt;-2,2|-3,1|1,-3|2,-2&gt;(T=0,(2,-2,D:6,S:6,T:2,F:7,~F:1,^95m,T=1)+) 
<p>The allocation of bits to device and subdevice (D:6, S:6) is a guess.</p>

<H2><A name="IODATAn">IODATA</A><i>n</i> and IODATA<i>n</i>-<i>x</i>-<i>y</i></H2>
UEI protocol: not known.
<br>
IRP notation: {38k,550}&lt;1,-1|1,-3&gt;(16,-8,x:7,D:7,S:7,y:7,F:8,C:4,1,^108m)+ 
{n = F:4 ^ F:4:4 ^ C:4} <br>
EFC translation: LSB
<p>This is potentially a class of protocols distinguished by values of <i>n</i>, <i>x</i> and <i>y</i> with 
    <i>n</i> = 0..15 and <i>x</i>, <i>y</i> = 0..127.  If <i>x</i> and <i>y</i> are both zero, they are omitted.  The only known example is IODATA1.</p>

<H2><A name="Jerrold">Jerrold</A></H2>
UEI protocol: 0006
<br>
IRP notation: {0k,44}&lt;1,-7.5m|1,-11.5m&gt;(F:5,1,-23.5m)+ 
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="JVC">JVC and JVC{2}</A></H2>
UEI protocol: 0034
<br>
IRP notation: {38k,525}&lt;1,-1|1,-3&gt;(16,-8,(D:8,F:8,1,-45)+) <br>
EFC translation: LSB comp
<p>JVC{2} indicates a JVC signal from which the lead-in is missing.  The JVC protocol has
lead-in on only the first frame, so it is quite easy to have it missing from a learned
signal.  So when JVC{2} is correct, it means the same as JVC.  But JVC{2} is not robust,
so <A href="#spurious">spurious decodes</A> are likely.  It
is also very similar in structure and timing to <A href="#Mitsubishi">Mitsubishi</A> protocol, so that
DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC
are all encoded the same way between the two.  So if you have JVC{2}
decodes that you have reason to suspect should actually be Mitsubishi, you can try using
them as Mitsubishi without changing the numbers.  However, true Mitsubishi signals will not
mis-decode as JVC, just as JVC{2}.  So if some of the signals for your device decode as JVC
and others as JVC{2}, you should trust all those decodes and not try Mitsubishi.</p>

<H2><A name="JVC-48">JVC-48</A></H2>
UEI protocol: 001F or 00C9 or 00CD
<br>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,3:8,1:8,D:8,S:8,F:8,(D^S^F):8,1,-173)+ 
<br>
EFC translation: LSB comp
<p>JVC-48 is the member of the Kaseikyo family with M=3 and N=1.</p>
<p>Panasonic protocol uses the same check byte rules as JVC-48, so you might want use the (more flexible)
Panasonic entries in KM or RM to produce a JVC-48 upgrade (by changing the OEM_code1(M) and OEM_code2(N) values).  For simple
JVC-48 upgrades you get exactly the same results by directly selecting the &quot;JVC-48&quot; protocol.</p>

<H2><A name="JVC-56">JVC-56</A></H2>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,3:8,1:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)+
<p>JVC-56 is the member of the Kaseikyo56 family with M=3 and N=1.</p>
 
<H2><A name="Kaseikyo">Kaseikyo</A></H2>
UEI protocol: 00F8 <br>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,G:8,1,-173)+ {X=M:4:0^M:4:4^N:4:0^N:4:4}
<br>
EFC translation: LSB comp
<p>Kaseikyo is a family of protocols that includes Panasonic, Mitsubishi-K, Fujitsu, JVC-48, Denon-K, Sharp-DVD and Teac-K.  
Each manufacturer is assigned a pair of identifiers, here identified as M and N.  If an IR signal matches a known pair of OEM 
identifiers and has the correct checksum behavior, it will be decoded with appropriate protocol name.  Otherwise it will 
be decoded as Kaseikyo.</p>
<p>

<H2><A name="Kaseikyo56">Kaseikyo56</A></H2>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,M:8,N:8,X:4,D:4,S:8,E:8,F:8,G:8,1,-173)+ {X=M:4:0^M:4:4^N:4:0^N:4:4}
Like Kaseikyo, each manufacturer is assigned a pair of identifiers identified as M and N.  If an IR signal matches a known pair of OEM 
identifiers and has the correct checksum behavior, it will be decoded with appropriate protocol name.  Otherwise it will 
be decoded as Kaseikyo56.</p>

<H2><A name="Kathrein">Kathrein</A></H2>
UEI protocol: 0066
<br>IRP notation: {38k,540}&lt;1,-1|1,-3&gt;(16,-8,D:4,~D:4,F:8,~F:8,1,^105m,(16,-8,F:8,1,^105m)+)
<br>EFC translation: LSB comp
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.  It is unusual in that the ditto 
    frame carries part of the signal data, specifically the function code (OBC) but not the device code. 
	Similar to Logitech, but both decodes give the same device number and OBC.</p>

<H2><A name="Konka">Konka</A></H2>
UEI protocol: 019B
<br>
IRP notation: {38k,500,msb}&lt;1,-3|1,-5&gt;(6,-6,D:8,F:8,1,-8,1,-46)+ <br>
EFC translation: MSB

<H2><A name="Lumagen">Lumagen</A></H2>
IRP notation: {38.4k,416,msb}&lt;1,-6|1,-12&gt;(D:4,C:1,F:7,1,-26)+ {C = (#F+1)&1}
<br>
EFC translation: MSB prepended with C bit.
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</p>

<H2><A name="Lutron">Lutron</A></H2>
IRP notation: {40k,2300,msb}&lt;-1|1&gt;(255:8,X:24,0:4)+ <br>
EFC translation: MSB of decoded signal.
<p>This is an unusual protocol in that an 8-bit device code and 8-bit OBC are encoded in a 24-bit 
    error-correcting code as the X of the IRP notation.  This is constructed as follows.  First two parity 
    bits are appended to the 16 data bits to give even parity for the two sets of 9 bits taken alternately.  
    The resulting 18-bit sequence is then treated as 6 octal digits (0-7) expressed in 3-bit binary code.  
    These are then re-coded in the 3-bit Gray code (also called, more descriptively, the reflected-binary code) 
    with a parity bit to give odd parity, so giving 6 4-bit groups treated as a single 24-bit sequence.  The 
    whole thing allows any single-bit error in transmission to be identified and corrected.</p>
	
<H2><A name="Logitech">Logitech</A></H2>
UEI protocol: 020B <br>
IRP notation: {38k,127}<3,-4|3,-8>(31,-36,D:4,~D:4,F:8,~F:8,3,-50m)+ <br>
<p>Logitech is used with their PS3 adapter.  The IR signal is similar to Kathrein.  If a Logitech signal is decoded 
as Kathrein, the device number and OBC are still correct.</p>

<H2><A name="Matsui">Matsui</A></H2>
IRP notation: {38K,525}&lt;1,-1|1,-3&gt;(D:3,F:7,1,^30.5m)+ <br>
EFC translation: Not available in this version of DecodeIr
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="MCE">MCE (RC6-6-32)</A></H2>
IRP notation: {36k,444,msb}&lt;-1,1|1,-1&gt;(6,-2,1:1,6:3,-2,2,OEM1:8,OEM2:8,T:1,D:7,F:8,^107m)+
<p>MCE is a member of the RC6 family.  Technically it is RC6-6-32 with the standard toggle bit zero, with the 
    OEM1 field equal to 128, and with a nonstandard (for the RC6 family) toggle bit added. If all those 
    rules are met, DecodeIr will display the name as &quot;MCE&quot; and with the OEM2 field moved to the 
    subdevice position.  Otherwise it will display RC6-6-32.</p>
<p>As of version 8.31, KM does not have built-in support for this protocol, but there are KM format upgrade 
    files available for Media Center (built by an expert who isn't limited to KM's built-in protocols).  Those 
    upgrades should be adaptable to any RC6-6-32 code set (by changing the fixed data), if the one you have 
    doesn't already match the upgrade.</p>
<p>RM version 1.16 has support for RC6-6-32, which can be used for MCE upgrades.  Version 1.17 will also have 
    direct support for MCE</p>
	
<H2><A name="Metz19">Metz19</A></H2>
IRP notation: (37.9K,106,msb)<4,-9|4,-16>(8,-22,T:1,D:3,~D:3,F:6,~F:6,4,-125m)+ <br>
The toggle bit T is inverted each time a new button press occurs.

<H2><A name="Mitsubishi">Mitsubishi</A></H2>
UEI protocol: 0014
<br>
IRP notation: {32.6k,300}&lt;1,-3|1,-7&gt;(D:8,F:8,1,-80)+ <br>
EFC translation: LSB comp
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.  It
is also very similar in structure and timing to <A href="#JVC">JVC{2}</A> protocol, so that
DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC
are all encoded the same way between the two.  So if you have Mitsubishi
decodes that you have reason to suspect should actually be JVC, you can try using
them as JVC without changing the numbers.</p>

<H2><A name="Mitsubishi-K">Mitsubishi-K</A></H2>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,35:8,203:8,X:4,D:8,S:8,F:8,T:4,1,-100)+ 
<br>
EFC translation: not available yet
<p>Mitsubishi-K is the member of the Kaseikyo family with OEM_code1=35 and OEM_code2=203.</p>

<H2><A name="NEC">NEC</A></H2>
NEC is a family of similar protocols including NEC1, NEC2, Tivo, Pioneer, Apple, NECx1 and NECx2.
If you get a decode whose protocol name is
simply &quot;NEC&quot; that indicates the learned signal is not complete (usually caused by
not holding the original remote's button long enough during learning).  Enough of
the signal is present to accurately determine the device, subdevice and OBC numbers.
But not enough is present to determine whether the protocol is NEC1 or NEC2.
<H3><A name="NEC12difference">Difference between NEC1 and NEC2</A></H3>
The difference between NEC1 and NEC2 only affects the signal sent by a long
keypress.  A short press sends the same signal in NEC1 and NEC2.

<H3><A name="Variant IRstreams in NEC protocols">Variant IRstreams in NEC protocols</A></H3>
For NEC1, NEC2, NECx1, and NECx2 protocols, the IRstream contains D:8,S:8,F:8,~F:8 <br>
However, some manufacturers (especially Yamaha and Onkyo) are breaking the "rule" that the 4th byte should be ~F:8<br>
Version 2.42 decodes these variants by adding suffixes to the protocol name depending on the IRstream:<br>
-y1: D:8,S:8,F:8,~F:7,F:1:7  (complement all of F except the MSB)<br>
-y2: D:8,S:8,F:8,F:1,~F:7:1  (complement all of F except the LSB)<br>
-y3: D:8,S:8,F:8,F:1,~F:6:1,F:1:7  (complement all of F except MSB and LSB)<br>
-rnc: D:8,S:8,F:8;~F:4:4,~F:4  (complement F and reverse the nibbles)<br>
-f16: D:8,S:8,F:8,E:8  (no relationship between the 3rd and 4th bytes)<br>

<H2><A name="NEC1">NEC1</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)*) 
<br>
EFC translation: LSB comp
<p>A few devices use NEC1 protocol at 40Khz, rather than the typical frequency.
When getting a decode of NEC1, if you notice that the frequency is closer to 40Khz than to 38Khz,
examine multiple learns from the same device to estimate whether the 40Khz frequency is a
learning error or a true characteristic of the device. If the 40Khz is correct, there are
methods in JP1, or MakeHex (whichever you are using) to reproduce NEC1 at 40Khz rather than the
usual frequency.</p>

<H2><A name="NEC2">NEC2</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:8,F:8,~F:8,1,^108m)+ <br>
EFC translation: LSB comp
<p>Pioneer is distinguished from NEC2 only by frequency.  So if your learning system does not
learn frequency accurately, it won't accurately distinguish Pioneer from NEC2.  All Pioneer signals
should have a device number in the range 160 to 175 and no subdevice.  No NEC2 signal should fit those
rules.  So you usually can determine whether the decision (by frequency) was wrong by checking the device numbers.</p>

<H2><A name="NECx">NECx</A></H2>
If you get a decode whose protocol name is
simply &quot;NECx&quot; that indicates the learned signal is not complete (usually caused by
not holding the original remote's button long enough during learning).  Enough of
the signal is present to accurately determining the device, subdevice and OBC numbers.
But not enough is present to determine the exact protocol, which is probably NECx1 or NECx2.  This
incomplete learn also makes it harder to distinguish NEC from NECx, so a decode of &quot;NECx&quot;
might be NEC1 or NEC2 or even Tivo or Pioneer.

<H2><A name="NECx1">NECx1</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(8,-8,D:8,S:8,F:8,~F8,1,^108m,(8,-8,D:1,1,^108m)*) <br>
EFC translation: LSB comp
<br>  Most, but not all NECx1 signals have S=D

<H2><A name="NECx2">NECx2</A></H2>
IRP notation: {38.0k,564}&lt;1,-1|1,-3&gt;(8,-8,D:8,S:8,F:8,~F8,1,^108m)+ <br>
EFC translation: LSB comp
<br>  Most, but not all  NECx2 signals have S=D

<H2><A name="Nokia">Nokia</A></H2>
IRP notation: {36k,msb}&lt;164,-276|164,-445|164,-614|164,-783&gt;(412,-276,D:8,S:8,F:8,164,^100m)+ 
<br>
EFC translation: MSB

<H2><A name="Nokia12">Nokia12</A></H2>
IRP notation: {36k,msb}&lt;164,-276|164,-445|164,-614|164,-783&gt;(412,-276,D:4,F:8,164,^100m)+ 
<br>
EFC translation: MSB

<H2><A name="Nokia32">Nokia32</A></H2>
UEI protocol: 0173
<br>
IRP notation: {36k,msb}&lt;164,-276|164,-445|164,-614|164,-783&gt;(412,-276,D:8,S:8,T:1,X:7,F:8,164,^100m)+ 
<br>
EFC translation: MSB
<p>The Nokia32 protocol is one variation of the RCMM 1.5 protocol developed by Philips.  RCMM refers to X as "System" and to D:2,S:4:4 as "Customer"</p>

<H2><A name="NRC16">NRC16</A></H2>
Documentation not written yet.

<H2><A name="NRC17">NRC17</A></H2>
UEI protocol: 00BD <br>
irp={500,38k,25%}&lt;-1,1|1,-1&gt;(1,-5,1:1,254:8,255:8,-28, (1,-5,1:1,F:8,D:8,-220)+, 1,-5,1:1,254:8,255:8,-200)<br>
<a href="http://www.sbprojects.com/knowledge/ir/nrc17.php"> Details of NRC17</a><br>


<H2><A name="OrtekMCE">OrtekMCE</A></H2>
UEI protocol: not known.
<br>
IRP notation: {38.6k,480}&lt;1,-1|-1,1&gt;([P=0][P=1][P=2],4,-1,D:5,P:2,F:6,C:4,-48m)+{C=3+#D+#P+#F}<br>
EFC translation: 6-bit LSB
<p>The <A href="#repeat">repeat frames</A> are not all identical. P is a position code: 0 for the start frame of a repeat sequence, 2 for the end frame and 1 for all frames in between. C is a checksum, 3 more than the number of 1 bits in D, P, F together.  DecodeIR v2.37
and later check P and will report in the Misc field if either the start or end frame, or both, is/are missing.</p>

<H2><A name="Pace MSS">Pace MSS</A></H2>
IRP notation: {38k,630,msb}&lt;1,-7|1,-11&gt;(1,-5,1,-5,T:1,D:1,F:8,1,^120m)+ 
<br>
EFC translation: Not available in this version of DecodeIr
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</p>

<H2><A name="Panasonic">Panasonic</A></H2>
UEI protocol: 001F or 00C9 or 00CD
<br>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,2:8,32:8,D:8,S:8,F:8,(D^S^F):8,1,-173)+ 
<br>
EFC translation: LSB comp
<p>Panasonic protocol is the most commonly seen member of the Kaseikyo family</p>
  <p>OEM_code1 is 2 and OEM_code2 is 32 (or DecodeIr won't display the name as &quot;Panasonic&quot;). 
    So those values in KM or RM can be changed from the default 2 and 32 only 
    when using the Panasonic entry in KM or RM to produce some Kaseikyo variant 
    OTHER THAN Panasonic. When creating a Panasonic upgrade, don't change those 
    from the default values.</p>

<H2><A name="Panasonic2">Panasonic2</A></H2>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,2:8,32:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)+ 

<H2><A name="Panasonic_Old">Panasonic_Old</A></H2>
UEI protocol: 0000 or 0087
<br>
IRP notation: {57.6k,833}&lt;1,-1|1,-3&gt;(4,-4,D:5,F:6,~D:5,~F:6,1,-44m)+ <br>
EFC translation: 6-bit LSB comp with 2-bit mini-combo
<p>Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.</p>

<H2><A name="PCTV">PCTV</A></H2>
IRP notation: {38.4k,832}&lt;0,-1|1,-0&gt;(2,-8,1,D:8,F:8,2,-???) 

<H2><A name="pid-0001">pid-0001</A></H2>
UEI protocol: 0001
<br>IRP notation:  {0k,msb}&lt;24,-9314|24,-13486&gt;(24,-21148,(F:5,1,-28m)+)
<br>EFC translation: 5-bit MSB comp
<p>As of version 8.31 KM has seriously wrong OBC translation for pid-0001, so use only EFC's with KM.</p>

<H2><A name="pid-0003">pid-0003</A></H2>
UEI protocol: 0003
<br>IRP notation:  {40.2k,389}&lt;2,-2|3,-1&gt;(F:8,~F:8,^102k)+
<br>EFC translation: LSB

<H2><A name="pid-0004">pid-0004</A></H2>
UEI protocol: 0004
<br>IRP notation:  {0k,msb}&lt12,-130|12,-372&gt(F:6,12,-27k)+
<br>EFC translation: 6-bit MSB comp

<H2><A name="pid-0083">pid-0083</A></H2>
UEI protocol: 0083
<br>EFC translation: 5-bit MSB comp
<br>IRP notation: {42.3K, 3000}&lt;1,-3,1,-7|1,-7,1,-3&gt;(F:5,1,-27)+
<p>This protocol is a very limited design.  We have seen it used only in the UEI setup code TV/0159,
which is for some TVs brand named Fisher, Sanyo and Sears.  It is not likely that any other code
set uses this protocol.  So if you get a correct decode of pid-0083 you probably have a TV that
can be controlled by the TV/0159 setup code.</p>
<p>As of version 8.31, KM does not translate OBC to EFC according to
the same rules used by DecodeIr.  RM does translate consistently with DecodeIr, so you may find
it easier to use RM.  If you use KM, you should use the EFC number from the decode not the OBC number.
Pid-0083 protocol
uses the same EFC numbering across all JP1 remotes, so use of EFC is safe.  KM uses different
OBC numbering than RM and DecodeIr, so use of OBCs isn't safe.</p>

<H2><A name="Pioneer">Pioneer</A></H2>
IRP notation: {40k,564}&lt;1,-1|1,-3&gt;(16,-8,D:8,S:8,F:8,~F:8,1,^108m)+ <br>
EFC translation: LSB comp
<p>Pioneer is distinguished from NEC2 only by frequency.  So if your learning system does not
learn frequency accurately, it won't accurately distinguish Pioneer from NEC2.  All Pioneer signals
should have a device number in the range 160 to 175 and no subdevice.  No NEC2 signal should fit those
rules.  So you usually can determine whether the decision (by frequency) was wrong by checking the device numbers.</p>
  <p>Many Pioneer commands are sent as combinations of two different Pioneer signals. 
    This version of DecodeIr does not associate the two signals together into 
    one command. It decodes them separately. If you get more than one of the same 
    OBC from decoding a learned signal, that just means the learning system failed 
    to understand the repeat pattern. It does not mean a two part signal. But 
    if there are two different OBCs (with the same or different device numbers) 
    you have a two part Pioneer signal.</p>
<p>Including a two part Pioneer signal in a KeyMove or upgrade is a complex process that requires a good
understanding of Pioneer signals and of the Pioneer support in KM.  The signals don't vary much among related Pioneer models.
So the best way to get an upgrade or hex cmd including such signals is to look through existing Pioneer upgrades in
the JP1 group and find one that already includes the same (or nearly same) signal.</p>

<H2><A name="Proton">Proton</A></H2>
UEI protocol: 005C
<br>
IRP notation: {38k,500}&lt;1,-1|1,-3&gt;(16,-8,D:8,1,-8,F:8,1,^63m)+ <br>
EFC translation: LSB comp
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="RC5">RC5</A></H2>
UEI protocol: 00E8
<br>
IRP notation: {36k,msb,889}&lt;1,-1|-1,1&gt;(1,~F:1:6,T:1,D:5,F:6,^114m)+ <br>
EFC translation: 6-bit MSB comp with 2-bit mini-combo
<p>Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.</p>
  <p>What we call &quot;device&quot; is really the &quot;System&quot; and what we 
    call &quot;OBC&quot; is really the &quot;Command&quot;. If you are using ProntoEdit 
    to create the RC5 signals directly, that GUI uses that correct (System and 
    Command) Philips terminology.</p>


<H2><A name="RC5-7F">RC5-7F</A></H2>
UEI protocol: 0182
<br>
IRP notation: {36k,msb,889}&lt;1,-1|-1,1&gt;(1, ~D:1:5,T:1,D:5,F:7,^114m)+ <br>
EFC translation: 7-bit MSB comp

<H2><A name="RC5-7F-57">RC5-7F-57</A></H2>
UEI protocol: 0182
<br>
IRP notation: {57k,msb,889}&lt;1,-1|-1,1&gt;(1, ~D:1:5,T:1,D:5,F:7,^114m)+ <br>
EFC translation: 7-bit MSB comp

<H2><A name="RC5x">RC5x</A></H2>
UEI protocol: 00F2
<br>
IRP notation: {36k,msb,889}&lt;1,-1|-1,1&gt;(1,~S:1:6,T:1,D:5,-4,S:6,F:6,^114m)+ 
<br>
EFC translation: NONE
<p>The official (UEI) protocol executor for RC5x does not support EFC numbers.  If you are creating an
upgrade in KM or RM you should use OBC numbers, not EFC numbers.  If you need the Hex Cmd for a KeyMove,
you should use the functions sheet of KM or RM to compute it for you from the OBC and subdevice number.</p>
<p>In the functions sheet in KM you must put the subdevice number in the byte2 column, which KM calls 
    &quot;unit code&quot;.</p>
  <p>What we call &quot;Device&quot; is really the &quot;System&quot;. What we call 
    Subdevice is really the &quot;Command&quot;. What we call &quot;OBC&quot; 
    is really the &quot;Data&quot;. If you are using ProntoEdit to create the 
    RC5 signals directly, that GUI uses the correct (System, Command and Data) 
    Philips terminology.</p>

<H2><A name="RC5-?-??">RC5-?-??</A></H2>
Just ignore this decode.  It is almost certainly <A href="#spurious">spurious</A>.  In case there is a new 
protocol I don't know about yet in the family with RC5 and StreamZap, it will decode in this form producing 
data to help me understand that protocol.

<H2><A name="RC6">RC6</A></H2>
UEI protocol: 0058
<br>IRP notation: {36k,444,msb}&lt;-1,1|1,-1&gt;(6,-2,1:1,0:3,&lt;-2,2|2,-2&gt;(T:1),D:8,F:8,^107m)+
<br>EFC translation: MSB
<p>RC6 is the name used for the first member of the RC6 family of protocols.  Technically this is
RC6-0-16, but DecodeIr will always display that as simply &quot;RC6&quot;</p>

<H2><A name="RC6-6-20">RC6-6-20</A></H2>
IRP notation: {36k,444,msb}&lt;-1,1|1,-1&gt;(6,-2,1:1,6:3,&lt;-2,2|2,-2&gt;(T:1),D:8,S:4,F:8,-???)+
<br>EFC translation: MSB
<p>This protocol is commonly used in Sky and Sky+ remotes.  As of version 8.31, KM does not have built-in support
for this protocol, but there are KM format upgrade files available for Sky and Sky+ (built by an expert who isn't limited
to KM's built-in protocols). RM has built-in support for RC6-M-20n protocol, which can be used to make Sky and Sky+
upgrades (or any other RC6-6-20 upgrades as long as the T bit is the same for all learned signals, as it is with Sky).
To use RC6-M-20n for RC6-6-20, you must leave the M field in RM's setup sheet with its default value of 6, and you
must set or leave the T field (if present) to the value shown in all the decodes (which I assume will be 0).</p>

<H2><A name="RC6-?-??">RC6-?-??</A></H2>
IRP notation: {36k,444,msb}&lt;-1,1|1,-1&gt;(6,-2,1:1,M:3,&lt;-2,2|2,-2&gt;(T:1),???:??)+
  <p>This is the generic form for a decode of protocols in the RC6 family. DecodeIr 
    uses this form for all RC6 decodes, except RC6-0-16 which is displayed as 
    simply &quot;RC6&quot;, RC6-6-24 which is displayed as &quot;Replay&quot; 
    and some RC6-6-32 which display as MCE.</p>
<p>The first ? in the protocol name is the M value in the RC6 spec.  The ending ?? represents the number of data bits
in the signal.</p>

<H2><A name="RCA">RCA and RCA(Old)</A></H2>
UEI protocols: 00AF (RCA), 002D(RCA(Old)) and 0114 (RCA Combo)
<br>IRP notation for RCA: {58k,460,msb}&lt;1,-2|1,-4&gt;(8,-8,D:4,F:8,~D:4,~F:8,1,-16)+
<br>IRP notation for RCA(Old): {58k,460,msb}&lt;1,-2|1,-4&gt;(32,(8,-8,D:4,F:8,~D:4,~F:8,2,-16)+)
<br>EFC translation: MSB
<p>These are two very similar forms of RCA protocol which differ only in that RCA(Old) has an extended lead-in 
and a double-length ON pulse before the lead-out.  They are so similar that most RCA devices will accept either.  
But some RCA devices only accept the one that really matches their own remote.
In versions of DecodeIR prior to v2.40, RCA(Old) was decoded as a frame of RCA{1} followed usually by a frame of RCA.  The second frame now no longer appears, so the protocol has been renamed to correspond to that used in KM and RM.</p>

<H2><A name="RCA-38">RCA-38 and RCA-38(Old)</A></H2>
UEI protocol: not known
<br>IRP notation for RCA-38: {38.7k,460,msb}&lt;1,-2|1,-4&gt;(8,-8,D:4,F:8,~D:4,~F:8,1,-16)+
<br>IRP notation for RCA-38(Old): {38.7k,460,msb}&lt;1,-2|1,-4&gt;(32,(8,-8,D:4,F:8,~D:4,~F:8,2,-16)+)
<br>EFC translation: MSB
<p>These are recently discovered variants of the RCA protocol.  They differ from RCA and RCA(Old) only in the 
    frequency, which is 38.7kHz instead of the standard 58kHz.</p>

<H2><A name="RECS80">RECS80</A></H2>
UEI protocol: 0045, 0068, 0090 or ???
<br>IRP notation for 0045: {38k,158,msb}&lt;1,-31|1,-47&gt;(1:1,T:1,D:3,F:6,1,-45m)+
<br>IRP notation for 0068: {33.3k,180,msb}&lt;1,-31|1,-47&gt;(1:1,T:1,D:3,F:6,1,^138m)+
<br>EFC translation: 6-bit MSB comp
<p>RECS80 is a family of related protocols with the same structure, but different timing.  See also
Velleman </p>
<p>These are moderately non robust protocols, so <A href="#spurious">spurious decodes</A> are possible.</p>
<p>The timing differences are not definitive enough for DecodeIr to identify which RECS80
version is which.  Instead it displays the timing information in the &quot;Misc&quot; field of the
output.  That will be three numbers formatted as in this example: (157/5048/7572).</p>
<p>Using those three numbers and the frequency, you should be able to determine whether
the signals fit the 0045 version, the 0068 version, the 0090 version or none of them.  You should look at all
the learned signals for your device together when doing that.  A single device won't mix
versions of RECS80, so any differences in frequency or timing between learns is
due to the IR learning process, not due to any differences among the correct signals.  You
should find one RECS80 version that is a good enough fit for all signals of the device.</p>
<p>For 0045,</p>
<ul>
<li>frequency should be between 37000 and 39000</li>
<li>first timing number between 100 and 200</li>
<li>second timing number between 4500 and 5500</li>
<li>third timing number between 6800 and 8300</li>
</ul>
<p>For 0068,</p>
<ul>
<li>frequency should be between 32300 and 34300</li>
<li>first timing number between 130 and 250</li>
<li>second timing number between 5100 and 6300</li>
<li>third timing number between 7700 and 9500</li>
</ul>
<p>For 0090,</p>
<ul>
<li>frequency should be 0</li>
<li>first timing number between 0 and 40</li>
<li>second timing number between 4500 and 5500</li>
<li>third timing number between 6800 and 8300</li>
</ul>
<p>You may find decodes that don't quite fit either.  If it almost fits, it may
be worth testing to see if it works, but it's most unlikely to work if the
second timing number is above the suggested max or the third timing number
is below the suggested min.  For example, I found a decode with frequency
41879 and timing numbers (132,5092,7652).  The three timing numbers are
perfect for protocol 0045, but the frequency is quite wrong.  I have no
device to test with, but my guess is that it would work anyway.  For
protocol 0068, the third number 7652 is below the minimum of 7700 making
it quite unlikely to work.  I found a different device with frequency
33333 and timing (450,5770,8656).  For 0068 all but the first number are
perfect and I would be quite surprised if it didn't work.  For 0045 the second
number 5770 is too high for the max of 5500, so it's unlikely to work.</p>
<p>The decodes for RECS80 all report EFCs for protocol 0045.  These are not
correct EFCs if you select a protocol other than 0045, so it is better to
use OBC numbers when creating a JP1 upgrade based on these decodes.</p>

<H2><A name="Replay">Replay</A></H2>
UEI protocol: 0092
<br>IRP notation: {36k,444,msb}&lt;-1,1|1,-1&gt;(6,-2,1:1,6:3,&lt;-2,2|2,-2&gt;(T:1),D:8,S:8,F:8,-100m)+
<br>EFC translation: MSB
<p>Replay is a member of the RC6 family.  Technically it is RC6-6-24, but DecodeIr will always
display the name as &quot;Replay&quot;.  ProntoEdit calls this protocol &quot;RC6 mode 6A&quot; and KM has it under the
alternate name &quot;RC-6a&quot; as well as its primary name &quot;Replay&quot;.  RM has it under the alternate name &quot;RC6-M-24n&quot; as
well as its primary name &quot;Replay&quot;.</p>
<p>DecodeIr's Subdevice field in  is called &quot;unit&quot; in KM</p>
<p>In ProntoEdit, DecodeIr's &quot;Device&quot; is called &quot;Customer Code&quot;; DecodeIr's &quot;Subdevice&quot; is called &quot;System&quot;;
and DecodeIr's &quot;OBC&quot; is called &quot;Command&quot;.</p>

<H2><A name="Revox">Revox</A></H2>
UEI protocol: 00A0
<br>IRP notation: {0k,15u}&lt;1,-9|1,-19&gt;(1:1,-10,0:1,D:4,F:6,1:1,-10,1:1,-100m)+
<p>Note that Revox uses no modulation.  Programs which require a modulation frequency might work with f= 66.7KHz</p>

<H2><A name="Samsung20">Samsung20</A></H2>
IRP notation: {38.4k,564}&lt;1,-1|1,-3&gt;(8,-8,D:6,S:6,F:8,1,^???)+
<br>EFC translation: LSB
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</p>

<H2><A name="Samsung36">Samsung36</A></H2>
UEI protocol: 01B5
<br>IRP notation: {38k,500}&lt;1,-1|1,-3&gt;(9,-9,D:8,S:8,1,-9,E:4,F:8,-68u,~F:8,1,-118)+
<br>EFC translation: LSB

<H2><A name="Sampo">Sampo</A></H2>
IRP notation: {38.4k, 833}&lt;1,-1|1,-3&gt;(4,-4,D:6,F:6,S:6,~F:6,1,-39)+
<br>EFC translation: Not available in this version of DecodeIr
<p>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</p>

<H2><A name="ScAtl-6">ScAtl-6</A></H2>
UEI protocol: 0078
<br>IRP notation: {57.6k,846}&lt1,-1|1,-3&gt(4,-4,D:6,F:6,~D:6,~F:6,1,-40)+
<br>EFC translation: 6-bit LSB comp
  <p>ScAtl-6 is distinguished from Emerson only by frequency. So if you are using 
    a learning system that doesn't record the frequency accurately, then DecodeIr 
    can't accurately select between Emerson and ScAtl-6.</p>
<p>In KM, this protocol is named &quot;Scientific Atlanta&quot;.  Most Scientific Atlanta cable tuners use Panasonic_Old
protocol, not this protocol.</p>

<H2><A name="Sejin-M-38">Sejin-<i>M</i>-38 and Sejin-<i>M</i>-56</A></H2>
UEI protocol: 0161
<br>
IRP notation for Sejin-<i>M</i>-38: {38.8k,310,msb}&lt;-1|1&gt;(&lt;8:4|4:4|2:4|1:4&gt;(3,3:2,Dx:8,Fx:8,Fy:8,E:4,C:4,-L))+ 
<br>
IRP notation for Sejin-<i>M</i>-56: {56.3k,310,msb}&lt;-1|1&gt;(&lt;8:4|4:4|2:4|1:4&gt;(3,3:2,Dx:8,Fx:8,Fy:8,E:4,C:4,-L))+ 
<br>
In both cases E is a checksum seed (0 in all known examples) and C is a checksum given by
<br>C = Dx:4 + Dx:4:4 + Fx:4 + Fx:4:4 + Fy:4 + Fy:4:4 + E.
<br>EFC translation: For Sejin-1, MSB.  For Sejin-2, EFC translation not available.
<p>The parameter <i>M</i> is either 1 or 2. It distinguishes two styles of this protocol that have different purposes and very different lead-out times L.  The 8-bit parameter Dx is a signed integer.  If Dx &gt; 0 then the style is Sejin-1, used for normal buttons of a remote control.  If Dx &lt; 0 then the style is Sejin-2, used for signals of an associated 2- or 3-button pointing device.  E is a checksum seed, E=0 in the only known examples.  The checksum formula reflects that in the UEI executor, so is
presumed correct.</p>

<p>The protocol parameters Dx, Fx, Fy translate into device parameters in different ways corresponding to the different uses of the protocol.  In Sejin-1 the device parameters are a Device Code, a SubDevice code and an OBC as is common for many protocols.  Sejin-2 has two sub-styles. One corresponds to the displacement of a cursor or other pointer with device parameters (X, Y) that
give the horizontal and vertical components of the displacement (and which can be positive or negative).  The other signals Button Up or Button Down for any of the three buttons of the pointing device.  The Misc field of the DecodeIR output displays these device parameters for the Sejin-2 signals.  The relationship between these and the protocol parameters is beyond the
scope of this document.  The Misc field also displays an RMOBC value for Sejin-2 signals, which is an artificial OBC value that can be used as input to RemoteMaster to create the signal concerned.</p>

<p>The protocol parameters for Sejin-1 include a bit that marks the end frame of a <A href="#repeat">repeat 
   sequence</A>.  DecodeIR v2.37 and later check this and will report in the Misc field if the end frame is 
   missing.  This will normally be due to the key still being held when the learning process ends, so that 
   the end frame gets omitted from the learned signal.  For Sejin-2 signals that represent button operations 
   the signal does not repeat.  A single frame is sent on button down, a different frame is sent once on 
   button up.  Both frames can be detected and distinguished by DecodeIR v2.37 and later but the button up 
   frame will not normally be present in a learned signal.</p>

<H2><A name="Sharp">Sharp, Sharp{1} and Sharp{2}</A></H2>
IRP notation: {38k,264}&lt;1,-3|1,-7&gt(D:5,F:8,1:2,1,-165,D:5,~F:8,2:2,1,-165)+
<br>EFC translation: LSB
  <p>A Sharp signal, which is identical to Denon, has two halves, either one of which is 
    enough to fully decode 
    the information. A significant fraction of Sharp learned signals contain just 
    one half or have the halves separated so that DecodeIr can't process them 
    together. When one half is seen separate from the other, DecodeIr will name 
    the protocol Sharp{1} or Sharp{2} depending on which half is decoded. Sharp, 
    Sharp{1} and Sharp{2} all represent the same protocol when they are correct. 
    But only Sharp is robust. A Sharp{1} or Sharp{2} decode might be <A href="#spurious">spurious</A>.</p>


<H2><A name="SharpDVD">SharpDVD</A></H2>
UEI protocol: 00F8
<br>
IRP notation: {38k,400}&lt;1,-1|1,-3&gt(8,-4,170:8,90:8,15:4,D:4,S:8,F:8,E:4,C:4,1,-48)+ {E=1,C=D^S:4:0^S:4:4^F:4:0^F:4:4^E:4}
<br> EFC translation: LSB comp
<p>SharpDVD is the member of the Kaseikyo family with OEM_code1=170 and OEM_code2=90.</p>

<H2><A name="SIM2">SIM2</A></H2>
IRP notation: {38.8k,400}&lt;3,-3|3,-7&gt;(6,-7,D:8,F:8,3,-60m) <br>
<p>Nearly identical timing to G.I. RG, so either decode is likely.</p>

<H2><A name="Solidtek16">Solidtek16</A></H2>
IRP notation: {38k}&lt;-624,468|468,-624&gt;(S=0,(1820,-590,0:1,D:4,F:7,S:1,C:4,1:1,-143m,S=1)3) {C= F:4:0 + F:3:4 + 8*S }
<p>
This is a KeyBoard protocol.  The make/break bit is decoded into the subdevice field.  Checksum is only known to be correct for D = 0</p>

<H2><A name="Solidtek20">Solidtek20</A></H2>
IRP notation: {38k}&lt;-624,468|468,-624&gt;(1820,-590,0:1,D:4,S:6,F:6,C:4,1:1,-???) 
<p>
This is a mouse protocol.  The button press info is included in the Device field.  The horizontal motion
is in the Subdevice field, and the vertical motion is in the OBC field.</p>
<p>The decode interface does not support returning negative Subdevice or OBC.  So negative motions are
represented by adding 64 to them.  The numbers 1 to 31 represent positive motion.  The numbers 32 to 63
are each 64 larger than the true negative motion, so 63 represents -1 and 32 represents -32.</p>

<H2><A name="Somfy">Somfy</A></H2>
IRP notation: {35.7k}&lt;308,-881|669,-520&gt;(2072,-484,F:2,D:3,C:4,-2300)+
<br>C is reported as SubDevice.  It is probably a check nibble {C = F*4 + D + 3}.
<br>F = 1 for UP or 2 for DOWN.
<br>D = 1, 2 or 3 for the three observed devices, or D = 0 to control all devices together.

<H2><A name="Sony8">Sony8</A></H2>
IRP notation: {40k,600}&lt;1,-1|2,-1&gt;(4,-1,F:8,^22200)
<br>EFC translation: LSB.

<H2><A name="Sony12">Sony12</A></H2>
UEI protocol: 00CA
<br>IRP notation: {40k,600}&lt;1,-1|2,-1&gt;(4,-1,F:7,D:5,^45m)+
<br>EFC translation: LSB.

<H2><A name="Sony15">Sony15</A></H2>
UEI protocol: 00CA
<br>IRP notation: {40k,600}&lt;1,-1|2,-1&gt;(4,-1,F:7,D:8,^45m)+
<br>EFC translation: LSB.

<H2><A name="Sony20">Sony20</A></H2>
UEI protocol: 00DE
<br>IRP notation: {40k,600}&lt;1,-1|2,-1&gt;(4,-1,F:7,D:5,S:8,^45m)+
<br>EFC translation: LSB.

<H2><A name="StreamZap">StreamZap</A></H2>
IRP notation: {36k,msb,889}&lt;1,-1|-1,1&gt;(1,~F:1:6,T:1,D:6,F:6,^114m)+
<br>DecodeIR V2.43 decodes this as RC5-7F
<br>EFC translation: 6-bit MSB comp

<H2><A name="StreamZap-57">StreamZap-57</A></H2>
IRP notation: {57k,msb,889}&lt;1,-1|-1,1&gt;(1,~F:1:6,T:1,D:6,F:6,^114m)+
<br>DecodeIR V2.43 decodes this as RC5-7F-57
<br>EFC translation: 6-bit MSB comp


<H2><A name="Sunfire">Sunfire</A></H2>
IRP notation: (38k,560,msb)&lt;1,-1|3,-1&gt;(16,-8, D:4,F:8,~D:4,~F:8, -32)+
<br>EFC translation: Not available in this version of DecodeIr

<H2><A name="TDC-38">TDC-38 and TDC-56</A></H2>
UEI protocol: 01BB (38KHz) 01BD (56KHz)
<br>
IRP notation for TDC-38: {38k,315,msb}&lt;-1,1|1,-1&gt;(1,-1,D:5,S:5,F:7,-89m)+
<br>IRP notation for TDC-56:  {56.3k,213,msb}&lt;-1,1|1,-1&gt;(1,-1,D:5,S:5,F:7,-89m)+
<br>EFC translation: 7-bit MSB.
<p>There are two variants of this protocol, with different frequencies but with the same number of carrier 
    cycles in each burst, which makes the duration of a burst also differ.  TDC-38 has a 38kHz carrier and is 
    used by Danish TDC IPTV.  TDC-56 has a 56.3kHz carrier and is used by Italian ALICE Home TV box.  These 
    implementations effectively use a 6-bit OBC as bit 0 of F is always the complement of bit 1, but there 
    are other implementations which do not follow that pattern.</p>

<H2><A name="Teac-K">Teac-K</A></H2>
UEI protocol: 00BB
<br>
IRP notation: {37k,432}&lt;1,-1|1,-3&gt;(8,-4,67:8,83:8,X:4,D:4,S:8,F:8,T:8,1,-100,(8,-8,1,-100)+
{T=D+S:4:0+S:4:4+F:4:0+F:4:4} <br>
EFC translation: LSB comp, two parts
<p>Teac-K is the member of the Kaseikyo family with OEM_code1=67 and OEM_code2=83.</p>
<p>Teac-K uses different repeat rules and a different check byte than other Kaseikyo protocols.</p>
<p>00BB requires 2-byte hex commands.  DecodeIr returns both hex cmd bytes through the interface that usually
means one or the other (for mini combos) but in this case it means both.</p>
<p>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</p>

<H2><A name="Thomson">Thomson</A></H2>
UEI protocol: 004B
<br>IRP notation: {33k,500}&lt;1,-4|1,-9&gt;(D:4,T:1,D:1:5,F:6,1,^80m)+
<br>EFC translation: 6-bit LSB comp, or that prepended with extra device bit.
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>
<p>DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of function) and reports these
    signals as Thompson7 (4 bits of device and 7 bits of function).</p>
<p>Thomson includes a <A HREF="#toggle">toggle bit</A> so using learned signals will have
operational problems.  You should use <A HREF="#jp1">KeyMoves or Upgrades</A> based on the decoded values,
rather than continue to use the learned signals.</p>
  <p>There are two different variants of UEI protocol 004B which have different 
    EFC numbering. The decode lists both possible EFCs so you could experiment 
    to discover which is right for your model. But, if you are creating an upgrade 
    (rather than just KeyMoves) it is better to use RM and use the OBC numbers 
    from the decode (which are stable across models of JP1 remote). As of version 
    8.31, KM does not have support for Thomson protocol, so if you must make an 
    upgrade in KM you need to use pid:004B. For the URC-8040 and 8060 the second 
    decoded EFC should be right and the OBC values in KM should be wrong. For 
    most (maybe all) other models, the first decoded EFC should be right and KM's 
    default EFC to OBC translation should also be right.</p>

<H2><A name="Thomson7">Thomson7</A></H2>
UEI protocol: 004B
<br>IRP notation: {33k,500}&lt;1,-4|1,-9&gt;(D:4,T:1,F:7,1,^80m)+
<br>EFC translation: 7-bit LSB comp
<p>DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of function) and reports these
    signals as Thompson7 (4 bits of device and 7 bits of function).</p>

<H2><A name="Tivo">Tivo</A></H2>
IRP notation: {38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,133:8,48:8,F:8,U:4,~F:4:4,1,-78,(16,-4,1,-173)*) 
<br>
EFC translation: LSB comp

<H2><A name="Velleman">Velleman</A></H2>
IRP notation: {38k,msb}&lt;700,-5060|700,-7590&gt;(1:1,T:1,D:3,F:6,1,-55m)+
<br>EFC translation: 6-bit MSB comp
<p>Very similar to RECS80-0045, except on duration is longer</p>

<H2><A name="Velodyne">Velodyne</A></H2>
IRP notation: {38k,136,msb}<210,-760>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15><br>(T=0,(S:4:4,~C:4,S:4,15:4,D:4,T:4,F:8,210u,-79m,T=8)+)) {C=(8+S:4+S:4:4+15+D+T+F:4+F:4:4)&15}
<br> Velodyne is a close relative of XMP.  

<H2><A name="Viewstar">Viewstar</A></H2>
UEI protocol: 0021
<br>IRP notation: {50.5k,337}&lt;1,-8|1,-5&gt;(F:5,1,-17)+
<br>EFC translation: 5-bit LSB comp
<p>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</p>

<H2><A name="X10">X10 and X10.<i>n</i></A></H2>
UEI protocol: 003F (X10.<i>n</i>), 01DF (X10)
<br>IRP notation for X10: {40.8k,565}&lt;2,-12|7,-7&gt;(7,-7,F:5,~F:5,21,-7)+
<br>IRP notation for X10.<i>n</i>: {40.8k,565}&lt;2,-12|7,-7&gt;(F:5,N:-4,21,-7,(7,-7,F:5,~F:5,21,-7)+)
<br>EFC translation: LSB of 2*OBC+1
<p>These are two variants of the same Home Automation protocol.  They differ in that X10.<i>n</i> has a 
    distinctive start frame that carries a sequence number, the <i>n</i> of the protocol name, in addition 
    to the OBC.  The repeat frames, and all frames of the X10 version, only carry the OBC.  The value 
    of <i>n</i> runs from 0 to 15 (or some lower value) and then restarts again at 0.  It is incremented on 
    each successive keypress.  A valid X10.<i>n</i> signal must have at least one repeat frame.  If this is 
    missing then the Misc column shows "invalid signal".</p>
<p>RemoteMaster has a single protocol, named X10 with PID 003F, that sends X10.<i>n</i> signals.  This is 
    the same as the UEI protocol with that PID.  There is no control over the value of <i>n</i>, this is 
    handled automatically by the remote.  The newer UEI protocol, with PID 01DF, sends X10 signals.</p>

<H2><A name="XMP">XMP, XMP-1 and XMP-2</A></H2>
UEI protocol: 016C
<br>IRP notation (without final frame): {38k,136,msb}<210,-760>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,(S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,-80.4m,T=8)+)){C1=-(15+S+S::4+15+OEM+OEM::4+D+D::4),C2=-(15+S+S:4+T+F+F::4+F::8+F::12)}
<br>IRP notation (with final frame):{38k,136,msb}<210,-760>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,((S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,[-80.4m][-80.4m][-13.8m],T=8)+,T=9)2)){C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S:4+T+F+F::4+F::8+F::12)}
<br>XMP uses one burst pair to encode numbers 0 to 15, with an on duration of 210uS, and off duration of 760uS + n*136uS where n takes on values of 0 to 15.
The checksum nibble is the complement of 15 plus the sum of the other 7 nibbles, mod 16

<br><br>The Device code is D, the SubDevice code is S and there are two OBC values.  OBC1 is the high byte 
of F, OBC2 is the low byte of F. The OEM code is normally 0x44 and is reported in the Misc field only if it 
has a different value. The XMP-1 protocol is XMP with OBC2 = 0.  The OBC field in DecodeIR then shows OBC1. 
The XMP-2 protocol is XMP with OBC1 = 0.  The OBC field in DecodeIR then shows OBC2.
<br><p>This protocol has a 4-bit toggle T that is 0 for the first frame and normally 8 for all repeat frames.  
    There is, however, a variant in which a further frame with T=9 is sent after the button is released, 
    separated from the preceding frame by the short leadout of 13.8m that is used between two half-frames 
    rather than the long lead-out of 80.4m used at the end of all other frames.  When this frame is detected 
    then the Misc field displays &quot;With Final Frame&quot;.  For this to be shown in a learned signal, the 
    button must be released before the learning process times out, so a short button press is needed.</p>

<p>These are problem decodes because JP1 remotes don't typically learn these signals accurately enough
for a correct decode.  NG Prontos also do a rotten job of learning these signals.  Older Prontos seem to do
fairly well.  DecodeIR v2.40 includes algorithms that attempt to reconstruct a valid XMP signal from a corrupt
learn, but it is impossible to correct all learning errors and there can be no certainty that a reconstruction
is actually correct.</p>
<p>In a correctly learned or fully reconstructed signal there will be an &quot;XMP&quot;, &quot;XMP-1&quot; or &quot;XMP-2&quot; decode with device, subdevice and OBC values that can be used with RemoteMaster or any similar
program to regenerate a clean signal.  The Misc field shows which algorithms, if any, have been applied, as a list in brackets after any decode data in this field.  There are notes below on the reliability of the various algorithms.  When the protocol shows as (unqualified) XMP, both OBC values are non-zero.  The OBC and Hex fields show OBC1.  The corresponding values for OBC2 are shown in the Misc field.</p>
<p>The learned signal itself will certainly not be valid if any reconstruction algorithms have been applied and
it may not be so even if it has been decoded without reconstruction.  The possible algorithm indicators in the 
Misc field are as follows:</p>
<ul>
<li>End (= Endpoint):  The lead-out burst is missing and has been inserted.  This is almost certainly correct.
<li>Rec (= Recovery):  Look-ahead has been used to recover a missing burst from the following repeat frame.  This is very likely to be correct.
<li>Cor (= Correction): Two bursts have been coalesced in the learning process, e.g. those for hex digits C and D, causing a C to appear as D or vice versa.
The error has been identified and corrected.  This is probably correct.
<li>Cal (= Calculated): A missing digit has been calculated from a checksum.  The digit is probably correct but it may be in the wrong place.  The most likely error in the reconstruction is that the two digits of the OBC are the wrong way round.
<li>Cal2 (= Calculated 2)  Two consecutive missing zero digits have been identified, corresponding to a zero OBC.  When this happens, the signal will always be shown as XMP-1.  The most likely error in the reconstruction is that it should actually be XMP-2.
</ul>
<p>If a learned signal is good enough to be recognised as XMP but not good enough to be fully reconstructed, the
protocol will display with a name of the form
<br><br>XMP:136.218-0F0F441A0A800F00
<br><br>
  In IR.exe you'll need to widen the Protocol column to see the whole thing. This 
  represents intermediate data from an unsuccessful attempt to decode a XMP signal. 

  The number in the position where the 136 is in this example represents the time scale.  A number (like this
example) that is near 137 is reasonable.  A number much further from 137 indicates a more serious learning or decoding
problem.
The number in the position where the .218 is in this example (it is not part of the 136) represents the level
of inconsistency in the individual hex digit decodes.  A value greater than .100 means the hex digits aren't very
reliable.</p>
<p>The hex string, where the 0F0F441A0A800F00 is, is the decoded data.  At least one digit is almost certainly wrong or
the whole decode wouldn't be displayed in this form.  With a JP1 learning remote, the most common errors are that a
digit is actually missing, in which case the string will have fewer than 16 hex digits, or that two
or more digits which are decoded the same are actually different, so some of them are correct and some are one value
higher or lower.  Although the reconstruction algorithms attempt to correct these types of errors, it is not always
possible.  In this example I happen to know the correct signal.  One of the three F's is really an E and one
of the two A's is really a 9.  The correct string is 0E0F441A09800F00.</p>
<p>Almost all examples we've seen start with &quot;0E0F441A0&quot; or &quot;060F44120&quot;.  But we've also seen upgrades from UEI for
&quot;0D1F441A0&quot; and &quot;0C2F441A0&quot; and &quot;0B3F441A0&quot;.
The last 4 digits of the whole 16 digit string (if they are correct) represent the Hex command needed to reproduce
the signal in a JP1 upgrade or KeyMove.  DecodeIR shows them as two 8-bit OBC values, as described with the IRP
notation above.</p>

<H2><A name="XX">XX</A></H2>
Documentation not written yet.

<H2><A name="Zaptor">Zaptor</A></H2>
UEI protocol: unknown
<br>IRP notation: {36k,330,msb}<-1,1|1,-1>[T=0] [T=0] [T=1] (8,-6,2,D:8,T:1,S:7,F:8,E:4,C:4,-74m)+ 
    {C = (D:4+D:4:4+S:4+S:3:4+8*T+F:4+F:4:4+E)&15}
<br>where T=0 for all frames except the last, T=1 for last frame, E is a checksum seed.  There is a 56KHz variant.
<br>EFC translation: MSB
<p>A protocol so far seen only in the Motorola Zaptor.  See also Amino</p>

<H2><A name="Zenith">Zenith</A></H2>
UEI protocol: 0022
IRP notation: {40k,520,msb}&lt;1,-10|1,-1,1,-8&gt;(S:1,<1:2|2:2>(F:D),-90m)+
<br>Before Version 2.43, this document has shown the IRP notation as {40k,520,msb}&lt;1,-1,1,-8|1,-10&gt;(S:1,<1:2|2:2>(F:D),-90m)+
<br>EFC translation: MSB 
<p>An unusual protocol, in that the number of bits in the function code is variable.  It is represented in 
    DecodeIR as the device code.  There are also two lead-in styles, decoded as subdevice values 0 and 1.  
    Style 1 aka "double-start" is usually used in TV's, other appliances use 0 aka "single start".  If the 
    device code is &gt;8 then the bytes given in the Misc field as E = ... follow the OBC in the function 
    code value.</p>

<H2><A name="?1-??-??-??">?1-??-??-??</A></H2>
An experimental decode I added based on the thread at
<A href="http://www.hifi-remote.com/forums/viewtopic.php?p=19168#19168">JP1-forum&quot;Unknown 
    Protocol&quot;</A>

</blockquote>
</BODY>
</HTML>
